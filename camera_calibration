import cv2
import numpy as np

# Define the calibration pattern (number of internal corners)
pattern_size = (16, 9)  # Change according to your calibration pattern

# Prepare object points (known 3D coordinates of the calibration pattern corners)
objp = np.zeros((np.prod(pattern_size), 3), dtype=np.float32)
objp[:, :2] = np.mgrid[0:pattern_size[0], 0:pattern_size[1]].T.reshape(-1, 2)

# Arrays to store object points and image points from all calibration images
obj_points = []  # 3D points in real-world coordinates
img_points = []  # 2D points in image coordinates

# Capture video frames and detect calibration pattern corners
cap = cv2.VideoCapture(r"C:\Users\ipekd\ENS491-RealityCapture\traffic_2 - Made with Clipchamp.mp4")  # Replace "your_video.mp4" with your video file path
while True:
    ret, frame = cap.read()
    if not ret:
        break
    
    # Convert frame to grayscale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    # Find calibration pattern corners
    found, corners = cv2.findChessboardCorners(gray, pattern_size, None)
    
    if found:
        # Add object points and image points to the lists
        obj_points.append(objp)
        img_points.append(corners)
        
        # Draw corners on the frame
        cv2.drawChessboardCorners(frame, pattern_size, corners, found)
    
    # Display the frame
    cv2.imshow("Calibration", frame)
    
    # Break if 'q' key is pressed
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release the video capture object
cap.release()
cv2.destroyAllWindows()

# Check if calibration pattern corners were detected
if len(obj_points) == 0:
    print("No calibration pattern corners were detected in the video frames.")
    exit()

# Perform camera calibration
ret, camera_matrix, dist_coeffs, rvecs, tvecs = cv2.calibrateCamera(
    obj_points, img_points, gray.shape[::-1], None, None
)

# Print the obtained camera matrix and distortion coefficients
print("Camera Matrix:")
print(camera_matrix)
print("\nDistortion Coefficients:")
print(dist_coeffs)
